// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("bs-platform/lib/js/belt_Int.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_SetInt = require("bs-platform/lib/js/belt_SetInt.js");

function to_instruction(raw_op, raw_n) {
  var operation;
  switch (raw_op) {
    case "acc" :
        operation = "accumulate";
        break;
    case "jmp" :
        operation = "jump";
        break;
    case "nop" :
        operation = "no_operation";
        break;
    default:
      throw {
            RE_EXN_ID: "Failure",
            _1: "operation 입력이 잘못되었습니다" + raw_op,
            Error: new Error()
          };
  }
  var result = Belt_Int.fromString(raw_n.replace("+", ""));
  var n;
  if (result !== undefined) {
    n = result;
  } else {
    throw {
          RE_EXN_ID: "Failure",
          _1: "입력의 오른쪽 부분을 정수로 변환하지 못했습니다." + raw_n,
          Error: new Error()
        };
  }
  return [
          operation,
          n
        ];
}

function parse_instruction(input) {
  var match = input.split(" ");
  if (match.length !== 2) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "instruction 입력이 잘못되었습니다." + input,
          Error: new Error()
        };
  }
  var raw_op = match[0];
  var raw_n = match[1];
  return to_instruction(raw_op, raw_n);
}

function parse_instructions(input) {
  return input.trim().split("\n").map(parse_instruction);
}

function execute(inst, now, acc) {
  var match = inst[0];
  if (match === "accumulate") {
    return [
            now + 1 | 0,
            acc + inst[1] | 0
          ];
  } else if (match === "no_operation") {
    return [
            now + 1 | 0,
            acc
          ];
  } else {
    return [
            now + inst[1] | 0,
            acc
          ];
  }
}

function stop_until_loop(_nowOpt, _accOpt, _visitedOpt, instructions) {
  while(true) {
    var nowOpt = _nowOpt;
    var accOpt = _accOpt;
    var visitedOpt = _visitedOpt;
    var now = nowOpt !== undefined ? nowOpt : 0;
    var acc = accOpt !== undefined ? accOpt : 0;
    var visited = visitedOpt !== undefined ? visitedOpt : [];
    if (visited.includes(now)) {
      var match = visited.pop();
      if (match !== undefined) {
        return acc;
      }
      throw {
            RE_EXN_ID: "Failure",
            _1: "visited가 비어있다니 어떻게 이럴 수가!",
            Error: new Error()
          };
    }
    var v = Belt_Array.get(instructions, now);
    var match$1;
    if (v !== undefined) {
      match$1 = execute(v, now, acc);
    } else {
      throw {
            RE_EXN_ID: "Failure",
            _1: "index가 범위를 벗어났습니다." + visited.toString(),
            Error: new Error()
          };
    }
    _visitedOpt = visited.concat([now]);
    _accOpt = match$1[1];
    _nowOpt = match$1[0];
    continue ;
  };
}

function correct_and_run(instructions) {
  var last_index = instructions.length - 1 | 0;
  var dfs = function (fixed, visited, param) {
    var acc = param[1];
    var now = param[0];
    var to_the_end = function (item, new_fixed) {
      return dfs(new_fixed, Belt_SetInt.add(visited, now), execute(item, now, acc));
    };
    var is_visited = Belt_SetInt.has(visited, now);
    var is_last = now === last_index;
    if (is_visited) {
      return [
              acc,
              "loop"
            ];
    }
    if (!is_last) {
      var match = instructions[now];
      var delta = match[1];
      var left_op = match[0];
      var match$1 = to_the_end([
            left_op,
            delta
          ], fixed);
      var left_ending = match$1[1];
      if (fixed || left_op === "accumulate" || left_ending === "success") {
        return [
                match$1[0],
                left_ending
              ];
      }
      var right_op = left_op === "no_operation" ? "jump" : "no_operation";
      return to_the_end([
                  right_op,
                  delta
                ], true);
    }
    var match$2 = execute(instructions[last_index], now, acc);
    return [
            match$2[1],
            "success"
          ];
  };
  var match = dfs(false, undefined, [
        0,
        0
      ]);
  if (match[1] === "success") {
    return match[0];
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "\xeb\x8b\xb5\xec\x9d\x84 \xec\xb0\xbe\xec\xa7\x80 \xeb\xaa\xbb\xed\x96\x88\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.",
        Error: new Error()
      };
}

exports.to_instruction = to_instruction;
exports.parse_instruction = parse_instruction;
exports.parse_instructions = parse_instructions;
exports.execute = execute;
exports.stop_until_loop = stop_until_loop;
exports.correct_and_run = correct_and_run;
/* No side effect */
